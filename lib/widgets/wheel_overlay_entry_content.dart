import 'dart:math';
import 'package:flutter/material.dart';
import 'package:wheel_color_picker/flow_delegates/flow_delegates.dart';
import 'package:wheel_color_picker/models/animation_config.dart';
import 'package:wheel_color_picker/models/fan_piece.dart';
import 'package:wheel_color_picker/models/fan_slice.dart';
import 'package:wheel_color_picker/models/layerlink_config.dart';
import 'package:wheel_color_picker/utils/math_util.dart';
import 'package:wheel_color_picker/wheel_color_picker.dart';

class WheelOverlayEntry extends StatefulWidget {
  final void Function(Color) onSelect;
  final Function? onTapOnEmptySpace;
  final FanAnimationConfig animationConfig;
  final Color color;
  final Offset? topLeft;
  final List<List<Color>> colors;
  final double pieceHeight;
  final double innerRadius;
  final double padding;
  final AnimationController animationController;
  final bool debugMode;
  final Alignment alignment;
  final LayerLinkConfig layerLinkConfig;

  const WheelOverlayEntry({
    Key? key,
    required this.colors,
    required this.onSelect,
    required this.pieceHeight,
    required this.animationController,
    this.alignment=Alignment.topLeft,
    this.padding = 0,
    this.innerRadius = 0,
    this.color = Colors.grey,
    this.animationConfig = const FanAnimationConfig(),
    this.topLeft,
    this.onTapOnEmptySpace,
    this.layerLinkConfig=const LayerLinkConfig(),
    this.debugMode = false,
  }) : super(key: key);

  @override
  State<StatefulWidget> createState() {
    return WheelOverlayEntryState();
  }
}

class WheelOverlayEntryState extends State<WheelOverlayEntry> {
  /// rotation animation, other animations are handled individually by each slice
  /// rotation is cancelled for now
  /// also see [FanSliceWidget]
  /// generated by [initState] -> [_initAnimation]
  late Animation<double> animation;

  /// List of fan pieces generated by [initState] -> [_initFanSliceList] with respect to colors
  List<FanSlice> fanSliceList = [];

  /// Center of the wheel, generated by [initState] -> [_initCalculateCenter]
  late Offset center;

  /// angle offset value notifier, initialized with 0 rotation
  /// when user pan on the wheel, rotate the wheel with angle
  /// ValueNotifier is used to reduce the amount of repaint
  ValueNotifier<double> angleOffsetNotifier = ValueNotifier(0);

  /// [outerRadius] is initialized by [initState] -> [_initCalculateOuterRadius]
  /// [_initCalculateOuterRadius] needs to be called before [_initCalculateCenter]
  late final double outerRadius;

  /// Initialize overlay entry content state
  /// [_initCalculateOuterRadius] needs to be called first
  /// [_initCalculateCenter] requires [_initCalculateOuterRadius] to have been called
  /// [_initFanSliceList] requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  /// [_initAnimation] is initializing a constant value for now, but if this rotation animation
  /// is enabled in the future, it requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  @override
  void initState() {
    super.initState();
    _initCalculateOuterRadius();
    _initCalculateCenter();
    _initFanSliceList();
    _initAnimation();
  }

  /// [_initAnimation] is initializing a constant value for now, but if this rotation animation
  /// is enabled in the future, it requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  void _initAnimation() {
    animation = ConstantTween<double>(0).animate(widget.animationController);
  }

  /// [_initCalculateCenter] requires [_initCalculateOuterRadius] to have been called
  /// computes [center]
  void _initCalculateCenter() {
    center = Offset(outerRadius + widget.padding/2, outerRadius + widget.padding/2);
  }

  /// [_initCalculateOuterRadius] needs to be called before [_initCalculateCenter]
  /// computes [outerRadius]
  void _initCalculateOuterRadius() {
    var maxCount = 0;
    for (var list in widget.colors) {
      if (list.length > maxCount) {
        maxCount = list.length;
      }
    }
    outerRadius = widget.innerRadius
        + (maxCount * widget.pieceHeight);
  }

  /// [_initFanSliceList] requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  /// computes [fanSliceList]
  void _initFanSliceList() {
    /// calculate the swipe of each slice by dividing 360(2pi) by slice count
    final double swipe = 2 * pi / widget.colors.length;

    /// start from 0 degree
    double startAngle = 0;

    for (var colorsInSlice in widget.colors) {
      /// for each color list create a new list of fan piece
      FanSlice slice = FanSlice(
          angleStart: startAngle,
          pieceHeight: widget.pieceHeight,
          swipe: swipe,
          innerRadius: widget.innerRadius,
          center: center
      );

      for (var color in colorsInSlice) {
        /// see [FanSlice.addFanPiece]
        slice.addFanPiece(color);
      }

      fanSliceList.add(slice);

      /// move to the next angle
      startAngle += swipe;
    }
  }

  /// rotate the wheel, increment the angle by [move]
  void increaseAngleOffset(double move) {
    angleOffsetNotifier.value += move;
  }

  /// on [FanPieceWidget] clicked, this function is invoked
  void callback (FanPiece fanPiece) {
    widget.onSelect(fanPiece.color);

    /// closing animation
    widget.animationController.reverse();
  }

  @override
  Widget build(BuildContext context) {
    Widget child = buildChild(context);
    return Align(
        alignment: (widget.layerLinkConfig.enabled)
            ? Alignment.topLeft
            : widget.alignment,
        child: (widget.layerLinkConfig.enabled && widget.layerLinkConfig.layerLink != null)
            ? CompositedTransformFollower(
                  link: widget.layerLinkConfig.layerLink!,
                  offset: Offset(
                    -outerRadius + widget.padding + widget.layerLinkConfig.buttonRadius,
                    -outerRadius + widget.padding + widget.layerLinkConfig.buttonRadius,
                  ),
                  child: child
              )
            : child
    );
  }

  Widget buildChild(BuildContext context) {
    return GestureDetector(
        onPanUpdate: (d) {
          final newR = MathUtil.getRadians(
              center: center,
              point: d.localPosition
          );
          final oldR = MathUtil.getRadians(
              center: center,
              point: Offset(
                  d.localPosition.dx - d.delta.dx,
                  d.localPosition.dy - d.delta.dy
              )
          );
          increaseAngleOffset(newR - oldR);
        },
        onTap: () {
          if (widget.onTapOnEmptySpace != null) {
            widget.onTapOnEmptySpace!();
          }
        },
        behavior: HitTestBehavior.translucent,
        child: ValueListenableBuilder(
            valueListenable: angleOffsetNotifier,
            builder: (context, value, child) {
              return Transform.rotate(
                  angle: angleOffsetNotifier.value,
                  child: Container(
                      width: outerRadius * 2 + widget.padding,
                      height: outerRadius * 2 + widget.padding,
                      color: widget.debugMode ? Colors.grey : null,
                      child: RepaintBoundary(
                          child: Flow(
                              delegate: FanFlowDelegation(
                                  center: center,
                                  animation: animation
                              ),
                              children: [
                                ...fanSliceList.map(
                                        (e) => FanSliceWidget(
                                      fanAnimationConfig: widget.animationConfig,
                                      callback: callback,
                                      fanSlice: e,
                                      controller: widget.animationController,
                                    )
                                )
                              ]
                          )
                      )
                  )
              );
            }
        )
    );
  }
}
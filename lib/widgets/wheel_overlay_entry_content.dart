import 'dart:math';
import 'package:flutter/material.dart';
import 'package:wheel_color_picker/flow_delegates/flow_delegates.dart';
import 'package:wheel_color_picker/models/animation_config.dart';
import 'package:wheel_color_picker/models/fan_piece.dart';
import 'package:wheel_color_picker/models/fan_slice.dart';
import 'package:wheel_color_picker/models/layerlink_config.dart';
import 'package:wheel_color_picker/utils/math_util.dart';
import 'package:wheel_color_picker/wheel_color_picker.dart';

/// {@template wheel_overlay_entry}
/// [WheelOverlayEntryContent] is the content of the Overlay that we want to
/// show. With this setup, on can use [WheelOverlayEntryContent] separately from
/// the main [WheelColorPicker] widget.
///
/// Also it saves some computation such that it only has to be built once when
/// parent widget is initializing, after the first time, parent widget just has
/// to pump new [OverlayEntry] with this as the content
/// {@endtemplate}
class WheelOverlayEntryContent extends StatefulWidget {

  /// WheelOverlayEntry uses [FanAnimationConfig] to determine open and close animation
  final FanAnimationConfig animationConfig;

  /// Each List<Color> is assigned a startAngle and will be converted into a [FanSlice] in [_initFanSliceList]
  /// [_initCalculateOuterRadius] loop through this list and find the longest list to determine max radius
  final List<List<Color>> colors;

  /// height of each fan piece
  final double pieceHeight;

  /// border size of fan piece
  final double pieceBorderSize;

  /// inner Radius of a donut, can't be lower than 0
  final double innerRadius;

  /// padding between outer radius and the outer container
  final double padding;

  /// animationController which
  final AnimationController animationController;

  /// debugMode will make the container background grey
  final bool debugMode;

  /// see [LayerLinkConfig]
  /// [WheelOverLayEntryContent] uses [layerLinkConfig] to decide whether to
  /// link this overlay to a target.
  /// This link is necessary for metric changes or scroll when you want
  /// the layer to stick to some element(target).
  ///
  /// When layerLinkConfig is not provided in constructor, it defaults to
  /// not-enabled, which causes the overlay to be a full-screen overlay with
  /// dimmer. [alignment] should be set to center in this case.
  ///
  /// When layerLinkConfig is provided and enabled, the layer will stick
  /// to the target, [alignment] should be set to topLeft in this case.
  /// TODO: refactor this part to have more flexible behaviour
  final LayerLinkConfig layerLinkConfig;
  final Alignment alignment;

  /// [hideOverlay] is invoked when dimmer container is being clicked
  /// while [LayerLinkConfig] is not enabled
  /// see what [LayerLinkConfig] does
  final Function? hideOverlay;

  /// invoked when user clicks on a [FanPieceWidget]
  final void Function(Color) onSelect;

  const WheelOverlayEntryContent({
    Key? key,
    required this.colors,
    required this.onSelect,
    required this.pieceHeight,
    required this.animationController,
    this.pieceBorderSize = 0,
    this.hideOverlay,
    this.alignment=Alignment.topLeft,
    this.padding = 0,
    this.innerRadius = 0,
    this.animationConfig = const FanAnimationConfig(),
    this.layerLinkConfig=const LayerLinkConfig(),
    this.debugMode = false,
  }) : super(key: key);

  @override
  State<StatefulWidget> createState() {
    return WheelOverlayEntryContentState();
  }
}

class WheelOverlayEntryContentState extends State<WheelOverlayEntryContent> {
  /// rotation animation, other animations are handled individually by each slice
  /// rotation is cancelled for now
  /// also see [FanSliceWidget]
  /// generated by [initState] -> [_initAnimation]
  late Animation<double> animation;

  /// Center of the wheel, generated by [initState] -> [_initCalculateCenter]
  late Offset center;

  /// List of fan pieces generated by [initState] -> [_initFanSliceList] with respect to colors
  List<FanSlice> fanSliceList = [];

  /// angle offset value notifier, initialized with 0 rotation
  /// when user pan on the wheel, rotate the wheel with angle
  /// ValueNotifier is used to reduce the amount of repaint
  ValueNotifier<double> angleOffsetNotifier = ValueNotifier(0);

  /// [outerRadius] is initialized by [initState] -> [_initCalculateOuterRadius]
  /// [_initCalculateOuterRadius] needs to be called before [_initCalculateCenter]
  late final double outerRadius;

  /// Initialize overlay entry content state
  /// [_initCalculateOuterRadius] needs to be called first
  /// [_initCalculateCenter] requires [_initCalculateOuterRadius] to have been called
  /// [_initFanSliceList] requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  /// [_initAnimation] is initializing a constant value for now, but if this rotation animation
  /// is enabled in the future, it requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  @override
  void initState() {
    super.initState();
    _initCalculateOuterRadius();
    _initCalculateCenter();
    _initFanSliceList();
    _initAnimation();
  }

  /// [_initAnimation] is initializing a constant value for now, but if this rotation animation
  /// is enabled in the future, it requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  void _initAnimation() {
    animation = ConstantTween<double>(0).animate(widget.animationController);
  }

  /// [_initCalculateCenter] requires [_initCalculateOuterRadius] to have been called
  /// computes [center]
  void _initCalculateCenter() {
    center = Offset(outerRadius + widget.padding/2, outerRadius + widget.padding/2);
  }

  /// [_initCalculateOuterRadius] needs to be called before [_initCalculateCenter]
  /// computes [outerRadius]
  void _initCalculateOuterRadius() {
    var maxCount = 0;
    for (var list in widget.colors) {
      if (list.length > maxCount) {
        maxCount = list.length;
      }
    }
    outerRadius = widget.innerRadius
        + (maxCount * widget.pieceHeight);
  }

  /// [_initFanSliceList] requires [_initCalculateOuterRadius] and [_initCalculateCenter] to have been called
  /// computes [fanSliceList]
  void _initFanSliceList() {
    /// calculate the swipe of each slice by dividing 360(2pi) by slice count
    final double swipe = 2 * pi / widget.colors.length;

    /// start from 0 degree
    double startAngle = 0;

    for (var colorsInSlice in widget.colors) {
      /// for each color list create a new list of fan piece
      FanSlice slice = FanSlice(
          angleStart: startAngle,
          pieceHeight: widget.pieceHeight,
          swipe: swipe,
          innerRadius: widget.innerRadius,
          center: center
      );

      for (var color in colorsInSlice) {
        /// see [FanSlice.addFanPiece]
        slice.addFanPiece(color);
      }

      fanSliceList.add(slice);

      /// move to the next angle
      startAngle += swipe;
    }
  }

  /// rotate the wheel, increment the angle by [move]
  void increaseAngleOffset(double move) {
    angleOffsetNotifier.value += move;
  }

  /// on [FanPieceWidget] clicked, this function is invoked
  void callback (FanPiece fanPiece) {
    widget.onSelect(fanPiece.color);

    /// closing animation
    widget.animationController.reverse();
  }

  @override
  Widget build(BuildContext context) {
    Widget child = buildChild(context);
    return Align(
        alignment: (widget.layerLinkConfig.enabled)
            ? Alignment.topLeft
            : widget.alignment,
        child: (widget.layerLinkConfig.enabled && widget.layerLinkConfig.layerLink != null)
            ? CompositedTransformFollower(
                  link: widget.layerLinkConfig.layerLink!,
                  offset: Offset(
                    -outerRadius + widget.padding + widget.layerLinkConfig.buttonRadius,
                    -outerRadius + widget.padding + widget.layerLinkConfig.buttonRadius,
                  ),
                  child: child
              )
            : GestureDetector(
            onTap: () {
              if (widget.hideOverlay != null) {
                widget.animationController.reverse();
                widget.hideOverlay!();
              }
            },
            child: Container(
                color: Colors.black38,
                width: double.infinity,
                height: double.infinity,
                child: Center(child:child)
            )

        )
    );
  }

  Widget buildChild(BuildContext context) {
    return GestureDetector(
        onPanUpdate: (d) {
          final newR = MathUtil.getRadians(
              center: center,
              point: d.localPosition
          );
          final oldR = MathUtil.getRadians(
              center: center,
              point: Offset(
                  d.localPosition.dx - d.delta.dx,
                  d.localPosition.dy - d.delta.dy
              )
          );
          increaseAngleOffset(newR - oldR);
        },
        onTap: () {
          if (widget.hideOverlay != null) {
            widget.animationController.reverse();
            widget.hideOverlay!();
          }
        },
        behavior: HitTestBehavior.translucent,
        child: ValueListenableBuilder(
            valueListenable: angleOffsetNotifier,
            builder: (context, value, child) {
              return Transform.rotate(
                  angle: angleOffsetNotifier.value,
                  child: Container(
                      width: outerRadius * 2 + widget.padding,
                      height: outerRadius * 2 + widget.padding,
                      color: widget.debugMode ? Colors.grey : null,
                      child: RepaintBoundary(
                          child: Flow(
                              delegate: FanFlowDelegation(
                                  center: center,
                                  animation: animation
                              ),
                              children: [
                                ...fanSliceList.map(
                                        (e) => FanSliceWidget(
                                      fanAnimationConfig: widget.animationConfig,
                                          callback: callback,
                                          pieceBorderSize: widget.pieceBorderSize,
                                          fanSlice: e,
                                      controller: widget.animationController,
                                    )
                                )
                              ]
                          )
                      )
                  )
              );
            }
        )
    );
  }
}